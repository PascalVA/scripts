#!/usr/bin/env python3

# /!\ THIS IS NOT SAFE FOR FILE NAMES CONTAINING SPACES /!\
#
# requirements:
# * exiftool
# * feh
#
# This script searches for a file called `imagedupes.log` in the user home
# directory. This file should be generated by findimagedupes.
#
# It will then make a list of all the files and open them in feh so the user
# can compare the files visually (to check for errors from findimagedupes)
# After, a list is presented and a user can choose a version to keep, delete
# all or skip the set of files.

# TODO: make input file a parameter or accept stream from stdin
# TODO: handle filenames containing spaces

import os
import subprocess

# read the file generated by imagedupes
with open(os.path.expanduser('~/imagedupes.log')) as f:
    lines = f.read().splitlines()

total_lines = len(lines)
for nr, line in enumerate(lines):
    files = line.split(" ")

    # clean up non-existing files before printing output
    _files = [f for f in files if os.path.isfile(f)]

    # Print information about the duplicates
    print('\n', '-' * 50, f'{nr}/{total_lines}', '-' * 50)
    if len(_files) <= 1:
        print('SKIPPED: no duplicates or no files found')
        continue
    print('IDX'.ljust(4),
          'File'.ljust(170),
          'Size'.ljust(10),
          'Create Date')
    for i, f in enumerate(_files):
        # human readable index starting from 1
        hrindex = i + 1

        filepath = f.rstrip()
        filename = os.path.basename(filepath)
        fstat = os.stat(filepath)

        filesize = str(fstat.st_size).rstrip()
        create_date = subprocess.check_output(
            f'exiftool -T -DateTimeOriginal  "{filepath}"',
            shell=True).decode().rstrip()
        print(
            str(hrindex).ljust(4),
            filepath.ljust(170),
            filesize.ljust(10),
            create_date,
        )

    # show images with feh so we can make sure they are not mismatched
    subprocess.check_output(
        "feh -Z --scale-down {}".format(" ".join(_files)),
        shell=True)

    # prompt the user what to do
    while True:
        keep_index = input('\nPlease enter one of the following:\n'
                           ' * IDX of the file you want to keep.\n'
                           ' * "a" to delete all\n'
                           ' * "" (empty string) to skip. \n\n'
                           '> ')
        try:
            keep_index = int(keep_index)
        except Exception:
            pass

        if keep_index in list(range(0, len(_files))) + ['a', '']:
            break
        print('Invalid index!')

    if keep_index == '':
        continue

    if keep_index != 'a':
        # delete all the files the user did not select
        _files.pop(keep_index-1)

    for filepath in _files:
        subprocess.call(f'rm {filepath}', shell=True)
        print(f'Removed file: {filepath})')
